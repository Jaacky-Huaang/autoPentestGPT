# an automated penetration testing parser empowered by GPT
import json
import os
import sys
import textwrap
import time
import traceback
import subprocess

import loguru
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.shortcuts import confirm
from rich.console import Console
from rich.spinner import Spinner

from pentestgpt.config.chat_config import ChatGPTConfig
from pentestgpt.prompts.prompt_class import PentestGPTPrompt
from pentestgpt.utils.APIs.module_import import dynamic_import
from pentestgpt.utils.chatgpt import ChatGPT
from pentestgpt.utils.prompt_select import prompt_ask, prompt_select
from pentestgpt.utils.task_handler import (
    local_task_entry,
    localTaskCompleter,
    main_task_entry,
    mainTaskCompleter,
)
from pentestgpt.utils.web_parser import google_search

logger = loguru.logger


def prompt_continuation(width, line_number, wrap_count):
    """
    The continuation: display line numbers and '->' before soft wraps.
    Notice that we can return any kind of formatted text from here.
    The prompt continuation doesn't have to be the same width as the prompt
    which is displayed before the first line, but in this example we choose to
    align them. The `width` input that we receive here represents the width of
    the prompt.
    """
    if wrap_count > 0:
        return " " * (width - 3) + "-> "
    text = ("- %i - " % (line_number + 1)).rjust(width)
    return HTML("<strong>%s</strong>") % text

def extract_string(text, start, end):
    """
    Extract the string between start and end
    """
    res = text.split(start)[1].split(end)
    return res[0], res[1]

class attackState:
    def __init__(self, attack_tree = "", target = "", prev_command = "", prev_result = ""):
        self.attack_tree = attack_tree
        self.target = target
        self.prev_command = prev_command
        self.prev_result = prev_result

    def __str__(self):
        # TODO: modify the string representation of the class
        return f"attack_tree: {self.attack_tree}, target: {self.target}, prev_command: {self.prev_command}, prev_result: {self.prev_result}"
    
        

class autoPentestGPT:

    def __init__(
        self,
        log_dir="logs",
        reasoning_model="gpt-4-turbo",
        parsing_model="gpt-4-turbo",
        useAPI=True,
        azure=False,
        use_langfuse_logging=False,
    ):
        self.log_dir = log_dir
        logger.add(sink=os.path.join(log_dir, "pentestGPT.log"))
        self.save_dir = "test_history"
        self.task_log = (
            {}
        )  # the information that can be saved to continue in the next session
        self.useAPI = useAPI
        self.parsing_char_window = 16000  # the chunk size for parsing in # of chars
        # TODO: link the parsing_char_window to the model used
        # load the module
        reasoning_model_object = dynamic_import(
            reasoning_model, self.log_dir, use_langfuse_logging=use_langfuse_logging
        )
        generation_model_object = dynamic_import(
            reasoning_model, self.log_dir, use_langfuse_logging=use_langfuse_logging
        )
        parsing_model_object = dynamic_import(
            parsing_model, self.log_dir, use_langfuse_logging=use_langfuse_logging
        )
        if useAPI is False:  # deprecated usage of cookie
            self.parsingAgent = ChatGPT(ChatGPTConfig(log_dir=self.log_dir))
            self.reasoningAgent = ChatGPT(
                ChatGPTConfig(model=reasoning_model, log_dir=self.log_dir)
            )
        else:
            self.summarizingAgent = parsing_model_object
            self.taskAgent = generation_model_object
            self.PTTAgent = reasoning_model_object
        self.prompts = PentestGPTPrompt
        self.console = Console()
        self.spinner = Spinner("line", "Processing")
        self.test_generation_session_id = None
        self.test_reasoning_session_id = None
        self.input_parsing_session_id = None
        self.chat_count = 0
        self.step_reasoning = (
            None  # the response from the reasoning session for the current step
        )
        self.history = {
            "user": [],
            "pentestGPT": [],
            "reasoning": [],
            "input_parsing": [],
            "generation": [],
            "exception": [],
        }  # the history of the current conversation

        # print the initialization message on the current implementation.
        self.console.print(
            "Welcome to pentestGPT, an automated penetration testing parser empowered by GPT.",
            style="bold green",
        )
        self.console.print("The settings are: ")
        self.console.print(
            f" - parsing model: {parsing_model_object.name}", style="bold green"
        )
        self.console.print(
            f" - reasoning model: {reasoning_model_object.name}", style="bold green"
        )
        self.console.print(f" - use API: {useAPI}", style="bold green")
        self.console.print(f" - log directory: {log_dir}", style="bold green")

    def log_conversation(self, source, text):
        """
        append the conversation into the history

        Parameters:
        ----------
        source: str
            the source of the conversation
        text: str
            the content of the conversation
        """
        # append the conversation into the history
        timestamp = time.time()
        if source not in self.history.keys():
            # an exception
            source = "exception"
        self.history[source].append((timestamp, text))

    def initialize(self):
        # Initialize the chatGPT sessions
        with self.console.status("[bold green] Initialize ChatGPT Sessions...") as status:
            try:
                (text_0, self.task_session_id) = self.taskAgent.send_new_message(self.prompts.generation_session_init)
                (text_1, self.PTT_session_id) = self.PTTAgent.send_new_message(self.prompts.reasoning_session_init)
                (text_2, self.summarizing_session_id) = self.summarizingAgent.send_new_message(self.prompts.input_parsing_init)
            except Exception as e:
                logger.error(e)
        self.console.print("- ChatGPT Sessions Initialized.", style="bold green")

        # TODO: open msfconsole
        # self.console.print("Opening msfconsole...", style="bold green")
        # msfconsole_result = os.system("/opt/metasploit-framework/bin/msfconsole")
        # print(f"msfconsole result: {msfconsole_result}")
        

        # 1. User firstly provide basic information of the task
        init_description = prompt_ask(
            "Please describe the penetration testing task in one line, including the target IP, task type, etc.\n> ",
            multiline=False,
        )
        self.log_conversation("user", init_description)
        self.task_log["task description"] = init_description
        # 2. Provide the information to the reasoning session for the task initialization.
        # Note that this information is not parsed by the three-step process in reasoning.
        # It is directly used to initialize the task.
        prefixed_init_description = self.prompts.task_description + init_description
        with self.console.status(
            "[bold green] Constructing Initial Penetration Testing Tree..."
        ) as status:
            PTT_raw = self.PTTAgent.send_message(
                prefixed_init_description, self.PTT_session_id
            )
        PTT = PTT_raw.split("$")[0]
        self.console.print("PentestGPT output: ", style="bold green")
        self.console.print(PTT)
        self.log_conversation("PentestGPT", "PentestGPT output:" + PTT)
        state = attackState(attack_tree=PTT, target=init_description)
        return state

    def reasoning_handler(self, text) -> str:
        # summarize the contents if necessary.
        if len(text) > self.parsing_char_window:
            text = self.input_parsing_handler(text)
        """
        # pass the information to reasoning_handler and obtain the results
        response = self.reasoningAgent.send_message(
            self.prompts.process_results + text, self.test_reasoning_session_id
        )
        # log the conversation
        """
        # PentestGPT Reasoning Logic
        ## 1. Given the information, update the PTT
        _updated_ptt_response = self.reasoningAgent.send_message(
            self.prompts.process_results + text, self.test_reasoning_session_id
        )
        ## 2. Validate if the PTT is correct
        # TODO
        ## 3. If the PTT is correct, select all the to-dos
        _task_selection_response = self.reasoningAgent.send_message(
            self.prompts.process_results_task_selection, self.test_reasoning_session_id
        )
        # get the complete output:
        response = _updated_ptt_response + _task_selection_response

        self.log_conversation("reasoning", response)
        return response

    def summarize_result(self, text) -> str:
        prompt = """Here is the content to be summarized: """
        
        # The default token-size limit is 4096 (web UI even shorter). 1 token ~= 4 chars in English
        # Use textwrap to split inputs. Limit to 2000 token (8000 chars) for each input
        # (1) replace all the newlines with spaces
        text = text.replace("\r", " ").replace("\n", " ")
        # (2) wrap the text
        wrapped_text = textwrap.fill(text, 8000)
        wrapped_inputs = wrapped_text.split("\n")
        # (3) send the inputs to chatGPT input_parsing_session and obtain the results
        summarized_content = ""
        for wrapped_input in wrapped_inputs:
            word_limit = f"Please ensure that the input is less than {8000 / len(wrapped_inputs)} words.\n"
            summarized_content += self.summarizingAgent.send_message(
                prompt + word_limit + wrapped_input, self.summarizing_session_id
            )
        # log the conversation
        self.log_conversation("input_parsing", summarized_content)
        return summarized_content
    
    def update_attack_tree(self, state):
        prompt = """Please update the attack tree based on the previous command and result. """
        content = f"Previous command: {state.prev_command}\nPrevious result: {state.prev_result}"
        new_attack_tree = self.PTTAgent.send_message(prompt + content, self.PTT_session_id)
        return new_attack_tree

    def get_exact_command(self, state):
        prompt = """Please provide the exact command to be executed. """
        content = f"Attack tree: {state.attack_tree}\ntarget: {state.target}"
        commands = self.taskAgent.send_message(prompt + content, self.task_session_id)
        return commands

    def execute_command(self, command):
        try:
            result = subprocess.run(command, shell=True, check=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return result.stdout
        except subprocess.CalledProcessError as e:
            print(f"Error executing command: {e}")
            print(f"Stderr: {e.stderr}")
            return e.stderr

    def input_handler(self, state) -> str: 

        # 0. Summarize the previous command and result
        if state.prev_command:
            summarized_prev_result = self.summarize_result(state.prev_result)
            state.prev_result = summarized_prev_result
            print(f"Summarized previous result: {summarized_prev_result}")

            # 1. Update the attack tree
            new_attack_tree = self.update_attack_tree(state)
            if "!Attack successful!" in new_attack_tree:
                self.console.print("Attack successful! Exiting the session...", style="bold green")
                return None
            state.attack_tree = new_attack_tree

        # 2. Get the command to be executed
        commands = self.get_exact_command(state)
        command_list = commands.split("$")

        # 3. Execute the command
        result_list = []
        for cur_command in command_list:
            print(f"Executing command: {cur_command}")
            cur_result = self.execute_command(cur_command)
            print(f"Result: {cur_result}")
            result_list.append(cur_result)
        updated_state = attackState(attack_tree=state.attack_tree, target=state.target, prev_command=commands, prev_result=result_list)
        
        # log this round of conversation
        self.log_conversation("pentestGPT", cur_command)
        
        return updated_state

    
    def main(self):
        """
        The main function of pentestGPT. The design is based on PentestGPT_design.md
        """
        # Ask for the user's request (target IP) and get the attack tree
        init_state = self.initialize()

        # enter the main loop.
        while True:
            try:
                # update the state
                state = self.input_handler(init_state)
                self.console.print(
                    "-----------------------------------------", style="bold white"
                )
                if not state:  # end the session
                    break
            except Exception as e:  # catch all general exception.
                # log the exception
                self.log_conversation("exception", str(e))
                # print the exception
                self.console.print(f"Exception: {str(e)}", style="bold red")
                # add a more detailed debugging
                exc_type, exc_obj, exc_tb = sys.exc_info()
                fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
                self.console.print(
                    "Exception details are below. You may submit an issue on github and paste the error trace",
                    style="bold green",
                )
                # self.console.print(exc_type, fname, exc_tb.tb_lineno)
                print(traceback.format_exc())
                # safely quit the session
                break
        # log the session. Save self.history into a txt file based on timestamp
        timestamp = time.time()
        log_name = f"pentestGPT_log_{str(timestamp)}.txt"
        # save it in the logs folder
        log_path = os.path.join(self.log_dir, log_name)
        with open(log_path, "w") as f:
            json.dump(self.history, f)



if __name__ == "__main__":

    pentestGPT = autoPentestGPT()
    pentestGPT.main()
